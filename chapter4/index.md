# 响应系统的作用与实现
## 响应式数据与副作用函数
副作用函数指的是会产生副作用的函数
```js
let a = 0;
function effect () {
  a = 1
}
function print(){
  console.log(a)
}
print()  //0
effect()
print()  //1
```
从以上代码可以看到，effect函数的执行修改了变量a，而print函数中读取了变量a，且两次读取的结果不一样，也就是说effect函数的执行直接或间接地影响了print函数的执行，这时我们就说effect函数产生了副作用。

那么什么是响应式数据呢？
```js
const obj = {
  name: 'lx'
}
function effect() {
  console.log(obj.name)
}
```
如上代码所示，effect函数读取了obj.name，当obj.name变化时，我们希望effect函数自动重新执行，如果能实现这一点，obj对象就是响应式数据。
通过观察可以发现：
1.当副作用函数执行时，会触发字段obj.name的读取操作
2.当修改obj.name的值时，会触发obj.name字段的设置操作
那么如果能拦截属性的读取和设置操作，当读取时存储副作用函数，当设置时就执行存储的副作用函数，实现响应式就成为了可能。
关键在于如何拦截属性的读取和设置操作，es2015之前使用Object.defineProperty,之后则使用Proxy
[一个能够实现最简单的响应式的例子]('./reactive1.js')
上面这个代码能够实现响应式，但是有很明显的缺陷，就是写死了副作用函数的名称effect，实际中的副作用函数可能是任意一个函数。
[提供了副作用函数的注册机]('./reactive2.js')
上面这个代码提供了一个副作用函数的注册机，这样我们可以使用任意的副作用函数。但是又发现如果在对象上添加了一个不存在的属性，副作用函数也重新执行了，我们本意是只在修改指定属性的时候执行副作用函数。为了解决这个问题，需要重新设计数据结构，将对象属性和副作用函数绑定起来。
[设计全新的桶结构]('./reactive3.js')
上面这个代码重新设计了数据桶的结构
![数据结构](./images/bucket%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.svg)
